<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>alpaka: alpaka::meta Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="alpaka_doxygen.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">alpaka
   </div>
   <div id="projectbrief">Abstraction Library for Parallel Kernel Acceleration</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacealpaka_1_1meta.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">alpaka::meta Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacealpaka_1_1meta_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealpaka_1_1meta_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structalpaka_1_1meta_1_1Contains.html">Contains</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structalpaka_1_1meta_1_1Contains_3_01List_3_01Head_00_01Tail_8_8_8_01_4_00_01Value_01_4.html">Contains&lt; List&lt; Head, Tail... &gt;, Value &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structalpaka_1_1meta_1_1CudaVectorArrayWrapper.html">CudaVectorArrayWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct providing [] subscript access to CUDA vector types.  <a href="structalpaka_1_1meta_1_1CudaVectorArrayWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structalpaka_1_1meta_1_1CudaVectorArrayWrapper_3_01TScalar_00_011_01_4.html">CudaVectorArrayWrapper&lt; TScalar, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structalpaka_1_1meta_1_1CudaVectorArrayWrapper_3_01TScalar_00_012_01_4.html">CudaVectorArrayWrapper&lt; TScalar, 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structalpaka_1_1meta_1_1CudaVectorArrayWrapper_3_01TScalar_00_013_01_4.html">CudaVectorArrayWrapper&lt; TScalar, 3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structalpaka_1_1meta_1_1CudaVectorArrayWrapper_3_01TScalar_00_014_01_4.html">CudaVectorArrayWrapper&lt; TScalar, 4 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structalpaka_1_1meta_1_1DependentFalseType.html">DependentFalseType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A false_type being dependent on a ignored template parameter. This allows to use static_assert in uninstantiated template specializations without triggering.  <a href="structalpaka_1_1meta_1_1DependentFalseType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalpaka_1_1meta_1_1InheritFromList.html">InheritFromList</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalpaka_1_1meta_1_1InheritFromList_3_01TList_3_01TBases_8_8_8_01_4_01_4.html">InheritFromList&lt; TList&lt; TBases... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structalpaka_1_1meta_1_1IntegerSequenceValuesInRange.html">IntegerSequenceValuesInRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the values in the index sequence are within the given range.  <a href="structalpaka_1_1meta_1_1IntegerSequenceValuesInRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structalpaka_1_1meta_1_1IntegerSequenceValuesInRange_3_01std_1_1integer__sequence_3_01T_00_01Tva6fcbf8e2bf818be858aa347bee2107be.html">IntegerSequenceValuesInRange&lt; std::integer_sequence&lt; T, Tvals... &gt;, T, Tmin, Tmax &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the values in the index sequence are within the given range.  <a href="structalpaka_1_1meta_1_1IntegerSequenceValuesInRange_3_01std_1_1integer__sequence_3_01T_00_01Tva6fcbf8e2bf818be858aa347bee2107be.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structalpaka_1_1meta_1_1IntegerSequenceValuesUnique.html">IntegerSequenceValuesUnique</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the values in the index sequence are unique.  <a href="structalpaka_1_1meta_1_1IntegerSequenceValuesUnique.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structalpaka_1_1meta_1_1IntegerSequenceValuesUnique_3_01std_1_1integer__sequence_3_01T_00_01Tvals_8_8_8_01_4_01_4.html">IntegerSequenceValuesUnique&lt; std::integer_sequence&lt; T, Tvals... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the values in the index sequence are unique.  <a href="structalpaka_1_1meta_1_1IntegerSequenceValuesUnique_3_01std_1_1integer__sequence_3_01T_00_01Tvals_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structalpaka_1_1meta_1_1IntegralValuesInRange.html">IntegralValuesInRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the integral values are within the given range.  <a href="structalpaka_1_1meta_1_1IntegralValuesInRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structalpaka_1_1meta_1_1IntegralValuesInRange_3_01T_00_01Tmin_00_01Tmax_01_4.html">IntegralValuesInRange&lt; T, Tmin, Tmax &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the integral values are within the given range.  <a href="structalpaka_1_1meta_1_1IntegralValuesInRange_3_01T_00_01Tmin_00_01Tmax_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structalpaka_1_1meta_1_1IntegralValuesInRange_3_01T_00_01Tmin_00_01Tmax_00_01I_00_01Tvals_8_8_8_01_4.html">IntegralValuesInRange&lt; T, Tmin, Tmax, I, Tvals... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the integral values are within the given range.  <a href="structalpaka_1_1meta_1_1IntegralValuesInRange_3_01T_00_01Tmin_00_01Tmax_00_01I_00_01Tvals_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structalpaka_1_1meta_1_1IntegralValuesUnique.html">IntegralValuesUnique</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the integral values are unique.  <a href="structalpaka_1_1meta_1_1IntegralValuesUnique.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structalpaka_1_1meta_1_1IsArrayOrVector.html">IsArrayOrVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structalpaka_1_1meta_1_1IsArrayOrVector_3_01CudaVectorArrayWrapper_3_01T_00_01N_01_4_01_4.html">IsArrayOrVector&lt; CudaVectorArrayWrapper&lt; T, N &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <em><a class="el" href="structalpaka_1_1meta_1_1IsArrayOrVector.html">IsArrayOrVector</a></em> for CUDA vector array wrapper.  <a href="structalpaka_1_1meta_1_1IsArrayOrVector_3_01CudaVectorArrayWrapper_3_01T_00_01N_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structalpaka_1_1meta_1_1IsArrayOrVector_3_01std_1_1array_3_01T_00_01N_01_4_01_4.html">IsArrayOrVector&lt; std::array&lt; T, N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structalpaka_1_1meta_1_1IsArrayOrVector_3_01std_1_1vector_3_01T_00_01A_01_4_01_4.html">IsArrayOrVector&lt; std::vector&lt; T, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structalpaka_1_1meta_1_1IsArrayOrVector_3_01T_0fN_0e_4.html">IsArrayOrVector&lt; T[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structalpaka_1_1meta_1_1max.html">max</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structalpaka_1_1meta_1_1min.html">min</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad0cbe491078fbefb5d6c6908dd4d799e"><td class="memTemplParams" colspan="2">template&lt;typename TList , template&lt; typename... &gt; class TApplicant&gt; </td></tr>
<tr class="memitem:ad0cbe491078fbefb5d6c6908dd4d799e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacealpaka_1_1meta.html#ad0cbe491078fbefb5d6c6908dd4d799e">Apply</a> = typename <a class="el" href="structalpaka_1_1meta_1_1detail_1_1ApplyImpl.html">detail::ApplyImpl</a>&lt; TList, TApplicant &gt;::type</td></tr>
<tr class="separator:ad0cbe491078fbefb5d6c6908dd4d799e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912098ffc7a3de7e5b522a451e81da24"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename... &gt; class TList, typename... Ts&gt; </td></tr>
<tr class="memitem:a912098ffc7a3de7e5b522a451e81da24"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacealpaka_1_1meta.html#a912098ffc7a3de7e5b522a451e81da24">CartesianProduct</a> = typename <a class="el" href="structalpaka_1_1meta_1_1detail_1_1CartesianProductImpl.html">detail::CartesianProductImpl</a>&lt; TList, Ts... &gt;::type</td></tr>
<tr class="separator:a912098ffc7a3de7e5b522a451e81da24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec9f76ad5048e654936626c56845f2c"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a8ec9f76ad5048e654936626c56845f2c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacealpaka_1_1meta.html#a8ec9f76ad5048e654936626c56845f2c">Concatenate</a> = typename <a class="el" href="structalpaka_1_1meta_1_1detail_1_1ConcatenateImpl.html">detail::ConcatenateImpl</a>&lt; T... &gt;::type</td></tr>
<tr class="separator:a8ec9f76ad5048e654936626c56845f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39137cbb1dfdb86f90c978f4cc59398e"><td class="memTemplParams" colspan="2">template&lt;typename TDstType , typename TIntegerSequence &gt; </td></tr>
<tr class="memitem:a39137cbb1dfdb86f90c978f4cc59398e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacealpaka_1_1meta.html#a39137cbb1dfdb86f90c978f4cc59398e">ConvertIntegerSequence</a> = typename <a class="el" href="structalpaka_1_1meta_1_1detail_1_1ConvertIntegerSequence.html">detail::ConvertIntegerSequence</a>&lt; TDstType, TIntegerSequence &gt;::type</td></tr>
<tr class="separator:a39137cbb1dfdb86f90c978f4cc59398e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e851602fef62781ed5eb23fb1d8fd6"><td class="memTemplParams" colspan="2">template&lt;typename TList , template&lt; typename &gt; class TPred&gt; </td></tr>
<tr class="memitem:a65e851602fef62781ed5eb23fb1d8fd6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacealpaka_1_1meta.html#a65e851602fef62781ed5eb23fb1d8fd6">Filter</a> = typename <a class="el" href="structalpaka_1_1meta_1_1detail_1_1FilterImpl.html">detail::FilterImpl</a>&lt; TList, TPred &gt;::type</td></tr>
<tr class="separator:a65e851602fef62781ed5eb23fb1d8fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa022767003bdbdb48057be42318fa982"><td class="memTemplParams" colspan="2">template&lt;typename List &gt; </td></tr>
<tr class="memitem:aa022767003bdbdb48057be42318fa982"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacealpaka_1_1meta.html#aa022767003bdbdb48057be42318fa982">Front</a> = typename <a class="el" href="structalpaka_1_1meta_1_1detail_1_1Front.html">detail::Front</a>&lt; List &gt;::type</td></tr>
<tr class="separator:aa022767003bdbdb48057be42318fa982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2977de255e74797d3699121598066dd2"><td class="memTemplParams" colspan="2">template&lt;typename T0 , typename T1 &gt; </td></tr>
<tr class="memitem:a2977de255e74797d3699121598066dd2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacealpaka_1_1meta.html#a2977de255e74797d3699121598066dd2">HigherMax</a> = std::conditional_t&lt;(sizeof(T0) &gt; sizeof(T1)), T0, std::conditional_t&lt;((sizeof(T0)==sizeof(T1)) &amp;&amp;std::is_unsigned_v&lt; T0 &gt; &amp;&amp;std::is_signed_v&lt; T1 &gt;), T0, T1 &gt; &gt;</td></tr>
<tr class="memdesc:a2977de255e74797d3699121598066dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type that has the higher max value.  <a href="namespacealpaka_1_1meta.html#a2977de255e74797d3699121598066dd2">More...</a><br /></td></tr>
<tr class="separator:a2977de255e74797d3699121598066dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf03afba38c7ce1e0f5ffd122cbed958"><td class="memTemplParams" colspan="2">template&lt;typename T0 , typename T1 &gt; </td></tr>
<tr class="memitem:abf03afba38c7ce1e0f5ffd122cbed958"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacealpaka_1_1meta.html#abf03afba38c7ce1e0f5ffd122cbed958">HigherMin</a> = std::conditional_t&lt;(std::is_unsigned_v&lt; T0 &gt;==std::is_unsigned_v&lt; T1 &gt;), std::conditional_t&lt; std::is_unsigned_v&lt; T0 &gt;, std::conditional_t&lt;(sizeof(T0)&lt; sizeof(T1)), T1, T0 &gt;, std::conditional_t&lt;(sizeof(T0)&lt; sizeof(T1)), T0, T1 &gt; &gt;, std::conditional_t&lt; std::is_unsigned_v&lt; T0 &gt;, T0, T1 &gt; &gt;</td></tr>
<tr class="memdesc:abf03afba38c7ce1e0f5ffd122cbed958"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type that has the higher min value. If both types have the same min value, the type with the wider range is chosen.  <a href="namespacealpaka_1_1meta.html#abf03afba38c7ce1e0f5ffd122cbed958">More...</a><br /></td></tr>
<tr class="separator:abf03afba38c7ce1e0f5ffd122cbed958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e58a91d9729169b90e61f495df98ebe"><td class="memTemplParams" colspan="2">template&lt;typename TSuperset , typename TSubset &gt; </td></tr>
<tr class="memitem:a3e58a91d9729169b90e61f495df98ebe"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacealpaka_1_1meta.html#a3e58a91d9729169b90e61f495df98ebe">IsIntegralSuperset</a> = std::integral_constant&lt; bool, std::is_integral_v&lt; TSuperset &gt; &amp;&amp;std::is_integral_v&lt; TSubset &gt; &amp;&amp;(((std::is_unsigned_v&lt; TSuperset &gt;==std::is_unsigned_v&lt; TSubset &gt;) &amp;&amp;(sizeof(TSuperset) &gt;=sizeof(TSubset)))||((std::is_unsigned_v&lt; TSuperset &gt; !=std::is_unsigned_v&lt; TSubset &gt;) &amp;&amp;(sizeof(TSuperset) &gt; sizeof(TSubset))))&gt;</td></tr>
<tr class="memdesc:a3e58a91d9729169b90e61f495df98ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The trait is true if all values of TSubset are contained in TSuperset.  <a href="namespacealpaka_1_1meta.html#a3e58a91d9729169b90e61f495df98ebe">More...</a><br /></td></tr>
<tr class="separator:a3e58a91d9729169b90e61f495df98ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7007c16b361a3bbc1184a79223d884dc"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a7007c16b361a3bbc1184a79223d884dc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacealpaka_1_1meta.html#a7007c16b361a3bbc1184a79223d884dc">IsParameterPackSet</a> = <a class="el" href="structalpaka_1_1meta_1_1detail_1_1IsParameterPackSetImpl.html">detail::IsParameterPackSetImpl</a>&lt; Ts... &gt;</td></tr>
<tr class="memdesc:a7007c16b361a3bbc1184a79223d884dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait that tells if the parameter pack contains only unique (no equal) types.  <a href="namespacealpaka_1_1meta.html#a7007c16b361a3bbc1184a79223d884dc">More...</a><br /></td></tr>
<tr class="separator:a7007c16b361a3bbc1184a79223d884dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232409af86c4d12e27e83406c7d6f6ca"><td class="memTemplParams" colspan="2">template&lt;typename TList &gt; </td></tr>
<tr class="memitem:a232409af86c4d12e27e83406c7d6f6ca"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacealpaka_1_1meta.html#a232409af86c4d12e27e83406c7d6f6ca">IsSet</a> = <a class="el" href="structalpaka_1_1meta_1_1detail_1_1IsSetImpl.html">detail::IsSetImpl</a>&lt; TList &gt;</td></tr>
<tr class="memdesc:a232409af86c4d12e27e83406c7d6f6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait that tells if the template contains only unique (no equal) types.  <a href="namespacealpaka_1_1meta.html#a232409af86c4d12e27e83406c7d6f6ca">More...</a><br /></td></tr>
<tr class="separator:a232409af86c4d12e27e83406c7d6f6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f48e52fec52f6bf6e10fec0da240aa"><td class="memTemplParams" colspan="2">template&lt;typename TBase , typename TDerived &gt; </td></tr>
<tr class="memitem:ac4f48e52fec52f6bf6e10fec0da240aa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacealpaka_1_1meta.html#ac4f48e52fec52f6bf6e10fec0da240aa">IsStrictBase</a> = std::integral_constant&lt; bool, std::is_base_of_v&lt; TBase, TDerived &gt; &amp;&amp;!std::is_same_v&lt; TBase, std::decay_t&lt; TDerived &gt; &gt;&gt;</td></tr>
<tr class="memdesc:ac4f48e52fec52f6bf6e10fec0da240aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The trait is true if TDerived is derived from TBase but is not TBase itself.  <a href="namespacealpaka_1_1meta.html#ac4f48e52fec52f6bf6e10fec0da240aa">More...</a><br /></td></tr>
<tr class="separator:ac4f48e52fec52f6bf6e10fec0da240aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3c6777dcdb44614e8c23dfe07c99d0"><td class="memTemplParams" colspan="2">template&lt;typename T0 , typename T1 &gt; </td></tr>
<tr class="memitem:a0f3c6777dcdb44614e8c23dfe07c99d0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacealpaka_1_1meta.html#a0f3c6777dcdb44614e8c23dfe07c99d0">LowerMax</a> = std::conditional_t&lt;(sizeof(T0)&lt; sizeof(T1)), T0, std::conditional_t&lt;((sizeof(T0)==sizeof(T1)) &amp;&amp;std::is_signed_v&lt; T0 &gt; &amp;&amp;std::is_unsigned_v&lt; T1 &gt;), T0, T1 &gt; &gt;</td></tr>
<tr class="memdesc:a0f3c6777dcdb44614e8c23dfe07c99d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type that has the lower max value.  <a href="namespacealpaka_1_1meta.html#a0f3c6777dcdb44614e8c23dfe07c99d0">More...</a><br /></td></tr>
<tr class="separator:a0f3c6777dcdb44614e8c23dfe07c99d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9bb8645940302e4f6477058666856fa"><td class="memTemplParams" colspan="2">template&lt;typename T0 , typename T1 &gt; </td></tr>
<tr class="memitem:af9bb8645940302e4f6477058666856fa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacealpaka_1_1meta.html#af9bb8645940302e4f6477058666856fa">LowerMin</a> = std::conditional_t&lt;(std::is_unsigned_v&lt; T0 &gt;==std::is_unsigned_v&lt; T1 &gt;), std::conditional_t&lt;(sizeof(T0) &gt; sizeof(T1)), T0, T1 &gt;, std::conditional_t&lt; std::is_signed_v&lt; T0 &gt;, T0, T1 &gt; &gt;</td></tr>
<tr class="memdesc:af9bb8645940302e4f6477058666856fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type that has the lower min value. If both types have the same min value, the type with the wider range is chosen.  <a href="namespacealpaka_1_1meta.html#af9bb8645940302e4f6477058666856fa">More...</a><br /></td></tr>
<tr class="separator:af9bb8645940302e4f6477058666856fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e231c413f4066784715ce6383c1762b"><td class="memTemplParams" colspan="2">template&lt;typename T , T Tbegin, T Tsize&gt; </td></tr>
<tr class="memitem:a8e231c413f4066784715ce6383c1762b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacealpaka_1_1meta.html#a8e231c413f4066784715ce6383c1762b">MakeIntegerSequenceOffset</a> = typename <a class="el" href="structalpaka_1_1meta_1_1detail_1_1MakeIntegerSequenceHelper.html">detail::MakeIntegerSequenceHelper</a>&lt;(Tsize&lt; 0),(Tsize==0), T, Tbegin, std::integral_constant&lt; T, Tbegin+Tsize &gt;, std::integer_sequence&lt; T &gt; &gt;::type</td></tr>
<tr class="separator:a8e231c413f4066784715ce6383c1762b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6e5b453ca068f43742cf89a32593dd"><td class="memTemplParams" colspan="2">template&lt;typename Ts , template&lt; typename... &gt; class TOp&gt; </td></tr>
<tr class="memitem:a4d6e5b453ca068f43742cf89a32593dd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacealpaka_1_1meta.html#a4d6e5b453ca068f43742cf89a32593dd">Transform</a> = typename <a class="el" href="structalpaka_1_1meta_1_1detail_1_1TransformImpl.html">detail::TransformImpl</a>&lt; Ts, TOp &gt;::type</td></tr>
<tr class="separator:a4d6e5b453ca068f43742cf89a32593dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d048c65329b66f46dca6575c3f524c"><td class="memTemplParams" colspan="2">template&lt;typename TList &gt; </td></tr>
<tr class="memitem:a49d048c65329b66f46dca6575c3f524c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacealpaka_1_1meta.html#a49d048c65329b66f46dca6575c3f524c">Unique</a> = typename <a class="el" href="structalpaka_1_1meta_1_1detail_1_1UniqueImpl.html">detail::UniqueImpl</a>&lt; TList &gt;::type</td></tr>
<tr class="memdesc:a49d048c65329b66f46dca6575c3f524c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait that returns a list with only unique (no equal) types (a set). Duplicates will be filtered out.  <a href="namespacealpaka_1_1meta.html#a49d048c65329b66f46dca6575c3f524c">More...</a><br /></td></tr>
<tr class="separator:a49d048c65329b66f46dca6575c3f524c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a84ac6dfa5a99a9fe32373cc4ac79947b"><td class="memTemplParams" colspan="2">template&lt;typename TFnObj , typename T &gt; </td></tr>
<tr class="memitem:a84ac6dfa5a99a9fe32373cc4ac79947b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="core_2Common_8hpp.html#aa8d02f0c4379afabdb7f4ee2e8f7954c">ALPAKA_NO_HOST_ACC_WARNING</a> <a class="el" href="core_2Common_8hpp.html#a4a195bd41eac945cee512865b6ef73f3">ALPAKA_FN_HOST_ACC</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacealpaka_1_1meta.html#a84ac6dfa5a99a9fe32373cc4ac79947b">foldr</a> (TFnObj const &amp;, T const &amp;t) -&gt; T</td></tr>
<tr class="separator:a84ac6dfa5a99a9fe32373cc4ac79947b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac639184c745981e545479ec110cb290e"><td class="memTemplParams" colspan="2">template&lt;typename TFnObj , typename T0 , typename T1 , typename... Ts&gt; </td></tr>
<tr class="memitem:ac639184c745981e545479ec110cb290e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="core_2Common_8hpp.html#aa8d02f0c4379afabdb7f4ee2e8f7954c">ALPAKA_NO_HOST_ACC_WARNING</a> <a class="el" href="core_2Common_8hpp.html#a4a195bd41eac945cee512865b6ef73f3">ALPAKA_FN_HOST_ACC</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacealpaka_1_1meta.html#ac639184c745981e545479ec110cb290e">foldr</a> (TFnObj const &amp;f, T0 const &amp;t0, T1 const &amp;t1, Ts const &amp;... ts)</td></tr>
<tr class="separator:ac639184c745981e545479ec110cb290e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84fa9b71d57092b3d9da78ee5eea68b4"><td class="memTemplParams" colspan="2">template&lt;typename TList , typename TFnObj , typename... TArgs&gt; </td></tr>
<tr class="memitem:a84fa9b71d57092b3d9da78ee5eea68b4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="core_2Common_8hpp.html#aa8d02f0c4379afabdb7f4ee2e8f7954c">ALPAKA_NO_HOST_ACC_WARNING</a> <a class="el" href="core_2Common_8hpp.html#a4a195bd41eac945cee512865b6ef73f3">ALPAKA_FN_HOST_ACC</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacealpaka_1_1meta.html#a84fa9b71d57092b3d9da78ee5eea68b4">forEachType</a> (TFnObj &amp;&amp;f, TArgs &amp;&amp;... args) -&gt; void</td></tr>
<tr class="memdesc:a84fa9b71d57092b3d9da78ee5eea68b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to boost::mpl::for_each but does not require the types of the sequence to be default constructible. This function does not create instances of the types instead it passes the types as template parameter.  <a href="namespacealpaka_1_1meta.html#a84fa9b71d57092b3d9da78ee5eea68b4">More...</a><br /></td></tr>
<tr class="separator:a84fa9b71d57092b3d9da78ee5eea68b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045597af75fc88f57bf8c02e3ecc4444"><td class="memTemplParams" colspan="2">template&lt;typename TExtentVec , typename TFnObj , std::size_t... Tdims&gt; </td></tr>
<tr class="memitem:a045597af75fc88f57bf8c02e3ecc4444"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="core_2Common_8hpp.html#aa8d02f0c4379afabdb7f4ee2e8f7954c">ALPAKA_NO_HOST_ACC_WARNING</a> <a class="el" href="core_2Common_8hpp.html#a4a195bd41eac945cee512865b6ef73f3">ALPAKA_FN_HOST_ACC</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacealpaka_1_1meta.html#a045597af75fc88f57bf8c02e3ecc4444">ndLoop</a> ([[maybe_unused]] std::index_sequence&lt; Tdims... &gt; const &amp;indexSequence, TExtentVec const &amp;extent, TFnObj const &amp;f) -&gt; void</td></tr>
<tr class="memdesc:a045597af75fc88f57bf8c02e3ecc4444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loops over an n-dimensional iteration index variable calling f(idx, args...) for each iteration. The loops are nested in the order given by the index_sequence with the first element being the outermost and the last index the innermost loop.  <a href="namespacealpaka_1_1meta.html#a045597af75fc88f57bf8c02e3ecc4444">More...</a><br /></td></tr>
<tr class="separator:a045597af75fc88f57bf8c02e3ecc4444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85354683c329835d1fa3e4da7de4c750"><td class="memTemplParams" colspan="2">template&lt;typename TExtentVec , typename TFnObj &gt; </td></tr>
<tr class="memitem:a85354683c329835d1fa3e4da7de4c750"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="core_2Common_8hpp.html#aa8d02f0c4379afabdb7f4ee2e8f7954c">ALPAKA_NO_HOST_ACC_WARNING</a> <a class="el" href="core_2Common_8hpp.html#a4a195bd41eac945cee512865b6ef73f3">ALPAKA_FN_HOST_ACC</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacealpaka_1_1meta.html#a85354683c329835d1fa3e4da7de4c750">ndLoopIncIdx</a> (TExtentVec const &amp;extent, TFnObj const &amp;f) -&gt; void</td></tr>
<tr class="memdesc:a85354683c329835d1fa3e4da7de4c750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loops over an n-dimensional iteration index variable calling f(idx, args...) for each iteration. The loops are nested from index zero outmost to index (dim-1) innermost.  <a href="namespacealpaka_1_1meta.html#a85354683c329835d1fa3e4da7de4c750">More...</a><br /></td></tr>
<tr class="separator:a85354683c329835d1fa3e4da7de4c750"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ad0cbe491078fbefb5d6c6908dd4d799e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0cbe491078fbefb5d6c6908dd4d799e">&#9670;&nbsp;</a></span>Apply</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TList , template&lt; typename... &gt; class TApplicant&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacealpaka_1_1meta.html#ad0cbe491078fbefb5d6c6908dd4d799e">alpaka::meta::Apply</a> = typedef typename <a class="el" href="structalpaka_1_1meta_1_1detail_1_1ApplyImpl.html">detail::ApplyImpl</a>&lt;TList, TApplicant&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Apply_8hpp_source.html#l00025">25</a> of file <a class="el" href="Apply_8hpp_source.html">Apply.hpp</a>.</p>

</div>
</div>
<a id="a912098ffc7a3de7e5b522a451e81da24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a912098ffc7a3de7e5b522a451e81da24">&#9670;&nbsp;</a></span>CartesianProduct</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename... &gt; class TList, typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacealpaka_1_1meta.html#a912098ffc7a3de7e5b522a451e81da24">alpaka::meta::CartesianProduct</a> = typedef typename <a class="el" href="structalpaka_1_1meta_1_1detail_1_1CartesianProductImpl.html">detail::CartesianProductImpl</a>&lt;TList, Ts...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CartesianProduct_8hpp_source.html#l00081">81</a> of file <a class="el" href="CartesianProduct_8hpp_source.html">CartesianProduct.hpp</a>.</p>

</div>
</div>
<a id="a8ec9f76ad5048e654936626c56845f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ec9f76ad5048e654936626c56845f2c">&#9670;&nbsp;</a></span>Concatenate</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacealpaka_1_1meta.html#a8ec9f76ad5048e654936626c56845f2c">alpaka::meta::Concatenate</a> = typedef typename <a class="el" href="structalpaka_1_1meta_1_1detail_1_1ConcatenateImpl.html">detail::ConcatenateImpl</a>&lt;T...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Concatenate_8hpp_source.html#l00030">30</a> of file <a class="el" href="Concatenate_8hpp_source.html">Concatenate.hpp</a>.</p>

</div>
</div>
<a id="a39137cbb1dfdb86f90c978f4cc59398e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39137cbb1dfdb86f90c978f4cc59398e">&#9670;&nbsp;</a></span>ConvertIntegerSequence</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDstType , typename TIntegerSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacealpaka_1_1meta.html#a39137cbb1dfdb86f90c978f4cc59398e">alpaka::meta::ConvertIntegerSequence</a> = typedef typename <a class="el" href="structalpaka_1_1meta_1_1detail_1_1ConvertIntegerSequence.html">detail::ConvertIntegerSequence</a>&lt;TDstType, TIntegerSequence&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IntegerSequence_8hpp_source.html#l00031">31</a> of file <a class="el" href="IntegerSequence_8hpp_source.html">IntegerSequence.hpp</a>.</p>

</div>
</div>
<a id="a65e851602fef62781ed5eb23fb1d8fd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e851602fef62781ed5eb23fb1d8fd6">&#9670;&nbsp;</a></span>Filter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TList , template&lt; typename &gt; class TPred&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacealpaka_1_1meta.html#a65e851602fef62781ed5eb23fb1d8fd6">alpaka::meta::Filter</a> = typedef typename <a class="el" href="structalpaka_1_1meta_1_1detail_1_1FilterImpl.html">detail::FilterImpl</a>&lt;TList, TPred&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Filter_8hpp_source.html#l00045">45</a> of file <a class="el" href="Filter_8hpp_source.html">Filter.hpp</a>.</p>

</div>
</div>
<a id="aa022767003bdbdb48057be42318fa982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa022767003bdbdb48057be42318fa982">&#9670;&nbsp;</a></span>Front</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacealpaka_1_1meta.html#aa022767003bdbdb48057be42318fa982">alpaka::meta::Front</a> = typedef typename <a class="el" href="structalpaka_1_1meta_1_1detail_1_1Front.html">detail::Front</a>&lt;List&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeListOps_8hpp_source.html#l00031">31</a> of file <a class="el" href="TypeListOps_8hpp_source.html">TypeListOps.hpp</a>.</p>

</div>
</div>
<a id="a2977de255e74797d3699121598066dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2977de255e74797d3699121598066dd2">&#9670;&nbsp;</a></span>HigherMax</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T0 , typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacealpaka_1_1meta.html#a2977de255e74797d3699121598066dd2">alpaka::meta::HigherMax</a> = typedef std::conditional_t&lt; (sizeof(T0) &gt; sizeof(T1)), T0, std::conditional_t&lt;((sizeof(T0) == sizeof(T1)) &amp;&amp; std::is_unsigned_v&lt;T0&gt; &amp;&amp; std::is_signed_v&lt;T1&gt;), T0, T1&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type that has the higher max value. </p>

<p class="definition">Definition at line <a class="el" href="Integral_8hpp_source.html#l00034">34</a> of file <a class="el" href="Integral_8hpp_source.html">Integral.hpp</a>.</p>

</div>
</div>
<a id="abf03afba38c7ce1e0f5ffd122cbed958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf03afba38c7ce1e0f5ffd122cbed958">&#9670;&nbsp;</a></span>HigherMin</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T0 , typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacealpaka_1_1meta.html#abf03afba38c7ce1e0f5ffd122cbed958">alpaka::meta::HigherMin</a> = typedef std::conditional_t&lt; (std::is_unsigned_v&lt;T0&gt; == std::is_unsigned_v&lt;T1&gt;), std::conditional_t&lt; std::is_unsigned_v&lt;T0&gt;, std::conditional_t&lt;(sizeof(T0) &lt; sizeof(T1)), T1, T0&gt;, std::conditional_t&lt;(sizeof(T0) &lt; sizeof(T1)), T0, T1&gt; &gt;, std::conditional_t&lt;std::is_unsigned_v&lt;T0&gt;, T0, T1&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type that has the higher min value. If both types have the same min value, the type with the wider range is chosen. </p>

<p class="definition">Definition at line <a class="el" href="Integral_8hpp_source.html#l00052">52</a> of file <a class="el" href="Integral_8hpp_source.html">Integral.hpp</a>.</p>

</div>
</div>
<a id="a3e58a91d9729169b90e61f495df98ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e58a91d9729169b90e61f495df98ebe">&#9670;&nbsp;</a></span>IsIntegralSuperset</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSuperset , typename TSubset &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacealpaka_1_1meta.html#a3e58a91d9729169b90e61f495df98ebe">alpaka::meta::IsIntegralSuperset</a> = typedef std::integral_constant&lt; bool, std::is_integral_v&lt;TSuperset&gt; &amp;&amp; std::is_integral_v&lt;TSubset&gt; &amp;&amp; ( ((std::is_unsigned_v&lt;TSuperset&gt; == std::is_unsigned_v&lt;TSubset&gt;) &amp;&amp; (sizeof(TSuperset) &gt;= sizeof(TSubset))) || ((std::is_unsigned_v&lt;TSuperset&gt; != std::is_unsigned_v&lt;TSubset&gt;) &amp;&amp; (sizeof(TSuperset) &gt; sizeof(TSubset))))&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The trait is true if all values of TSubset are contained in TSuperset. </p>

<p class="definition">Definition at line <a class="el" href="Integral_8hpp_source.html#l00027">27</a> of file <a class="el" href="Integral_8hpp_source.html">Integral.hpp</a>.</p>

</div>
</div>
<a id="a7007c16b361a3bbc1184a79223d884dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7007c16b361a3bbc1184a79223d884dc">&#9670;&nbsp;</a></span>IsParameterPackSet</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacealpaka_1_1meta.html#a7007c16b361a3bbc1184a79223d884dc">alpaka::meta::IsParameterPackSet</a> = typedef <a class="el" href="structalpaka_1_1meta_1_1detail_1_1IsParameterPackSetImpl.html">detail::IsParameterPackSetImpl</a>&lt;Ts...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trait that tells if the parameter pack contains only unique (no equal) types. </p>

<p class="definition">Definition at line <a class="el" href="meta_2Set_8hpp_source.html#l00045">45</a> of file <a class="el" href="meta_2Set_8hpp_source.html">Set.hpp</a>.</p>

</div>
</div>
<a id="a232409af86c4d12e27e83406c7d6f6ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a232409af86c4d12e27e83406c7d6f6ca">&#9670;&nbsp;</a></span>IsSet</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TList &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacealpaka_1_1meta.html#a232409af86c4d12e27e83406c7d6f6ca">alpaka::meta::IsSet</a> = typedef <a class="el" href="structalpaka_1_1meta_1_1detail_1_1IsSetImpl.html">detail::IsSetImpl</a>&lt;TList&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trait that tells if the template contains only unique (no equal) types. </p>

<p class="definition">Definition at line <a class="el" href="meta_2Set_8hpp_source.html#l00059">59</a> of file <a class="el" href="meta_2Set_8hpp_source.html">Set.hpp</a>.</p>

</div>
</div>
<a id="ac4f48e52fec52f6bf6e10fec0da240aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4f48e52fec52f6bf6e10fec0da240aa">&#9670;&nbsp;</a></span>IsStrictBase</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TBase , typename TDerived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacealpaka_1_1meta.html#ac4f48e52fec52f6bf6e10fec0da240aa">alpaka::meta::IsStrictBase</a> = typedef std:: integral_constant&lt;bool, std::is_base_of_v&lt;TBase, TDerived&gt; &amp;&amp; !std::is_same_v&lt;TBase, std::decay_t&lt;TDerived&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The trait is true if TDerived is derived from TBase but is not TBase itself. </p>

<p class="definition">Definition at line <a class="el" href="IsStrictBase_8hpp_source.html#l00019">19</a> of file <a class="el" href="IsStrictBase_8hpp_source.html">IsStrictBase.hpp</a>.</p>

</div>
</div>
<a id="a0f3c6777dcdb44614e8c23dfe07c99d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f3c6777dcdb44614e8c23dfe07c99d0">&#9670;&nbsp;</a></span>LowerMax</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T0 , typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacealpaka_1_1meta.html#a0f3c6777dcdb44614e8c23dfe07c99d0">alpaka::meta::LowerMax</a> = typedef std::conditional_t&lt; (sizeof(T0) &lt; sizeof(T1)), T0, std::conditional_t&lt;((sizeof(T0) == sizeof(T1)) &amp;&amp; std::is_signed_v&lt;T0&gt; &amp;&amp; std::is_unsigned_v&lt;T1&gt;), T0, T1&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type that has the lower max value. </p>

<p class="definition">Definition at line <a class="el" href="Integral_8hpp_source.html#l00041">41</a> of file <a class="el" href="Integral_8hpp_source.html">Integral.hpp</a>.</p>

</div>
</div>
<a id="af9bb8645940302e4f6477058666856fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9bb8645940302e4f6477058666856fa">&#9670;&nbsp;</a></span>LowerMin</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T0 , typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacealpaka_1_1meta.html#af9bb8645940302e4f6477058666856fa">alpaka::meta::LowerMin</a> = typedef std::conditional_t&lt; (std::is_unsigned_v&lt;T0&gt; == std::is_unsigned_v&lt;T1&gt;), std::conditional_t&lt;(sizeof(T0) &gt; sizeof(T1)), T0, T1&gt;, std::conditional_t&lt;std::is_signed_v&lt;T0&gt;, T0, T1&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type that has the lower min value. If both types have the same min value, the type with the wider range is chosen. </p>

<p class="definition">Definition at line <a class="el" href="Integral_8hpp_source.html#l00060">60</a> of file <a class="el" href="Integral_8hpp_source.html">Integral.hpp</a>.</p>

</div>
</div>
<a id="a8e231c413f4066784715ce6383c1762b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e231c413f4066784715ce6383c1762b">&#9670;&nbsp;</a></span>MakeIntegerSequenceOffset</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , T Tbegin, T Tsize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacealpaka_1_1meta.html#a8e231c413f4066784715ce6383c1762b">alpaka::meta::MakeIntegerSequenceOffset</a> = typedef typename <a class="el" href="structalpaka_1_1meta_1_1detail_1_1MakeIntegerSequenceHelper.html">detail::MakeIntegerSequenceHelper</a>&lt; (Tsize &lt; 0), (Tsize == 0), T, Tbegin, std::integral_constant&lt;T, Tbegin + Tsize&gt;, std::integer_sequence&lt;T&gt; &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IntegerSequence_8hpp_source.html#l00077">77</a> of file <a class="el" href="IntegerSequence_8hpp_source.html">IntegerSequence.hpp</a>.</p>

</div>
</div>
<a id="a4d6e5b453ca068f43742cf89a32593dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d6e5b453ca068f43742cf89a32593dd">&#9670;&nbsp;</a></span>Transform</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ts , template&lt; typename... &gt; class TOp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacealpaka_1_1meta.html#a4d6e5b453ca068f43742cf89a32593dd">alpaka::meta::Transform</a> = typedef typename <a class="el" href="structalpaka_1_1meta_1_1detail_1_1TransformImpl.html">detail::TransformImpl</a>&lt;Ts, TOp&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transform_8hpp_source.html#l00025">25</a> of file <a class="el" href="Transform_8hpp_source.html">Transform.hpp</a>.</p>

</div>
</div>
<a id="a49d048c65329b66f46dca6575c3f524c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d048c65329b66f46dca6575c3f524c">&#9670;&nbsp;</a></span>Unique</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TList &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacealpaka_1_1meta.html#a49d048c65329b66f46dca6575c3f524c">alpaka::meta::Unique</a> = typedef typename <a class="el" href="structalpaka_1_1meta_1_1detail_1_1UniqueImpl.html">detail::UniqueImpl</a>&lt;TList&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trait that returns a list with only unique (no equal) types (a set). Duplicates will be filtered out. </p>

<p class="definition">Definition at line <a class="el" href="Unique_8hpp_source.html#l00045">45</a> of file <a class="el" href="Unique_8hpp_source.html">Unique.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a84ac6dfa5a99a9fe32373cc4ac79947b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84ac6dfa5a99a9fe32373cc4ac79947b">&#9670;&nbsp;</a></span>foldr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFnObj , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_2Common_8hpp.html#aa8d02f0c4379afabdb7f4ee2e8f7954c">ALPAKA_NO_HOST_ACC_WARNING</a> <a class="el" href="core_2Common_8hpp.html#a4a195bd41eac945cee512865b6ef73f3">ALPAKA_FN_HOST_ACC</a> auto alpaka::meta::foldr </td>
          <td>(</td>
          <td class="paramtype">TFnObj const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; T
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Fold_8hpp_source.html#l00018">18</a> of file <a class="el" href="Fold_8hpp_source.html">Fold.hpp</a>.</p>

</div>
</div>
<a id="ac639184c745981e545479ec110cb290e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac639184c745981e545479ec110cb290e">&#9670;&nbsp;</a></span>foldr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFnObj , typename T0 , typename T1 , typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_2Common_8hpp.html#aa8d02f0c4379afabdb7f4ee2e8f7954c">ALPAKA_NO_HOST_ACC_WARNING</a> <a class="el" href="core_2Common_8hpp.html#a4a195bd41eac945cee512865b6ef73f3">ALPAKA_FN_HOST_ACC</a> auto alpaka::meta::foldr </td>
          <td>(</td>
          <td class="paramtype">TFnObj const &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T0 const &amp;&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts const &amp;...&#160;</td>
          <td class="paramname"><em>ts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Fold_8hpp_source.html#l00024">24</a> of file <a class="el" href="Fold_8hpp_source.html">Fold.hpp</a>.</p>

</div>
</div>
<a id="a84fa9b71d57092b3d9da78ee5eea68b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84fa9b71d57092b3d9da78ee5eea68b4">&#9670;&nbsp;</a></span>forEachType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TList , typename TFnObj , typename... TArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_2Common_8hpp.html#aa8d02f0c4379afabdb7f4ee2e8f7954c">ALPAKA_NO_HOST_ACC_WARNING</a> <a class="el" href="core_2Common_8hpp.html#a4a195bd41eac945cee512865b6ef73f3">ALPAKA_FN_HOST_ACC</a> auto alpaka::meta::forEachType </td>
          <td>(</td>
          <td class="paramtype">TFnObj &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to boost::mpl::for_each but does not require the types of the sequence to be default constructible. This function does not create instances of the types instead it passes the types as template parameter. </p>

<p class="definition">Definition at line <a class="el" href="ForEachType_8hpp_source.html#l00051">51</a> of file <a class="el" href="ForEachType_8hpp_source.html">ForEachType.hpp</a>.</p>

</div>
</div>
<a id="a045597af75fc88f57bf8c02e3ecc4444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a045597af75fc88f57bf8c02e3ecc4444">&#9670;&nbsp;</a></span>ndLoop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TExtentVec , typename TFnObj , std::size_t... Tdims&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_2Common_8hpp.html#aa8d02f0c4379afabdb7f4ee2e8f7954c">ALPAKA_NO_HOST_ACC_WARNING</a> <a class="el" href="core_2Common_8hpp.html#a4a195bd41eac945cee512865b6ef73f3">ALPAKA_FN_HOST_ACC</a> auto alpaka::meta::ndLoop </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] std::index_sequence&lt; Tdims... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>indexSequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtentVec const &amp;&#160;</td>
          <td class="paramname"><em>extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFnObj const &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loops over an n-dimensional iteration index variable calling f(idx, args...) for each iteration. The loops are nested in the order given by the index_sequence with the first element being the outermost and the last index the innermost loop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexSequence</td><td>A sequence of indices being a permutation of the values [0, dim-1]. </td></tr>
    <tr><td class="paramname">extent</td><td>N-dimensional loop extent. </td></tr>
    <tr><td class="paramname">f</td><td>The function called at each iteration. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="NdLoop_8hpp_source.html#l00089">89</a> of file <a class="el" href="NdLoop_8hpp_source.html">NdLoop.hpp</a>.</p>

</div>
</div>
<a id="a85354683c329835d1fa3e4da7de4c750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85354683c329835d1fa3e4da7de4c750">&#9670;&nbsp;</a></span>ndLoopIncIdx()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TExtentVec , typename TFnObj &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_2Common_8hpp.html#aa8d02f0c4379afabdb7f4ee2e8f7954c">ALPAKA_NO_HOST_ACC_WARNING</a> <a class="el" href="core_2Common_8hpp.html#a4a195bd41eac945cee512865b6ef73f3">ALPAKA_FN_HOST_ACC</a> auto alpaka::meta::ndLoopIncIdx </td>
          <td>(</td>
          <td class="paramtype">TExtentVec const &amp;&#160;</td>
          <td class="paramname"><em>extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFnObj const &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loops over an n-dimensional iteration index variable calling f(idx, args...) for each iteration. The loops are nested from index zero outmost to index (dim-1) innermost. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extent</td><td>N-dimensional loop extent. </td></tr>
    <tr><td class="paramname">f</td><td>The function called at each iteration. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="NdLoop_8hpp_source.html#l00117">117</a> of file <a class="el" href="NdLoop_8hpp_source.html">NdLoop.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacealpaka.html">alpaka</a></li><li class="navelem"><a class="el" href="namespacealpaka_1_1meta.html">meta</a></li>
    <li class="footer">Generated on Thu Feb 24 2022 12:54:47 for alpaka by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
